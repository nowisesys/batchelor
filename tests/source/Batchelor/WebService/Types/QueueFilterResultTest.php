<?php

namespace Batchelor\WebService\Types;

use InvalidArgumentException;

/**
 * Generated by PHPUnit_SkeletonGenerator on 2018-08-08 at 13:16:06.
 */
class QueueFilterResultTest extends \PHPUnit_Framework_TestCase
{

        /**
         * @var QueueFilterResult
         */
        protected $object;

        protected function setUp()
        {
                $this->object = new QueueFilterResult();
        }

        public function testDefault()
        {
                $object = $this->object;
                $expect = QueueFilterResult::NONE;
                $actual = $object();
                $this->assertSame($actual, $expect);
        }

        public function testGetValue()
        {
                $expect = QueueFilterResult::NONE;
                $actual = $this->object->getValue();
                $this->assertSame($actual, $expect);
        }

        public function testHasValue()
        {
                $expect = QueueFilterResult::NONE;
                $actual = $this->object->hasValue(QueueFilterResult::NONE);
                $this->assertTrue($actual == $expect);
                
                $expect = QueueFilterResult::NONE;
                $actual = $this->object->hasValue(QueueFilterResult::PENDING);
                $this->assertFalse($actual == $expect);
        }

        public function testGetName()
        {
                $expect = 'NONE';
                $actual = $this->object->getName();
                $this->assertSame($actual, $expect);
        }

        public function testAliases()
        {
                $object = new QueueFilterResult(QueueFilterResult::ALL);
                $object = new QueueFilterResult(QueueFilterResult::SUCCESSS);
                $object = new QueueFilterResult(QueueFilterResult::WAITING);
        }

        public function testException()
        {
                $constants = $this->object->getConstants();

                foreach ($constants as $constant) {
                        $object = new QueueFilterResult($constant);
                }

                $this->expectException(InvalidArgumentException::class);
                $object = new QueueFilterResult('missing');
        }

        public function testInvoke()
        {
                $expect = true;
                $actual = is_callable($this->object);
                $this->assertTrue($actual);

                $object = $this->object;        // can't use $this->object with invoke
                $expect = QueueFilterResult::NONE;
                $actual = $object();
                $this->assertSame($expect, $actual);
        }

        public function testGetConstants()
        {
                $actual = $this->object->getConstants();
                $this->assertNotNull($actual);
                $this->assertTrue(is_array($actual));
                $this->assertTrue(count($actual) != 0);
        }

        public function testHasConstant()
        {
                $expect = true;
                $actual = $this->object->hasConstant(QueueFilterResult::ALL);
                $this->assertNotNull($actual);
                $this->assertSame($expect, $actual);

                $expect = false;
                $actual = $this->object->hasConstant("missing");
                $this->assertNotNull($actual);
                $this->assertSame($expect, $actual);
        }

        public function testCallStatic()
        {
                $enum1 = QueueFilterResult::RECENT();   // Create enum object using magic static call
                $enum2 = new QueueFilterResult(QueueFilterResult::RECENT);

                $this->assertNotNull($enum1);
                $this->assertNotSame($enum1, $enum2);                           // Different objects
                $this->assertSame($enum1(), $enum2());                          // Same enum value
                $this->assertSame(get_class($enum1), get_class($enum2));        // Same class name
                $this->assertSame(get_class($enum1), QueueFilterResult::class); // Same class name

                $this->assertTrue($enum1 == $enum2);            // Same enum value
                $this->assertFalse($enum1 === $enum2);          // Same enum value, but different objects.

                $enum1 = QueueFilterResult::PENDING();
                $enum2 = QueueFilterResult::PENDING();

                $this->assertNotNull($enum1);
                $this->assertNotSame($enum1, $enum2);                           // Different objects
                $this->assertSame($enum1(), $enum2());                          // Same enum value
                $this->assertSame(get_class($enum1), get_class($enum2));        // Same class name
                $this->assertSame(get_class($enum1), QueueFilterResult::class); // Same class name

                $this->assertTrue($enum1 == $enum2);            // Same enum value
                $this->assertFalse($enum1 === $enum2);          // Same enum value, but different objects.

                $enum1 = QueueFilterResult::PENDING();
                $enum2 = QueueFilterResult::WAITING();

                $this->assertNotNull($enum1);
                $this->assertNotSame($enum1, $enum2);                           // Different objects
                $this->assertSame($enum1(), $enum2());                          // Same enum value
                $this->assertSame(get_class($enum1), get_class($enum2));        // Same class name
                $this->assertSame(get_class($enum1), QueueFilterResult::class); // Same class name

                $this->assertTrue($enum1 == $enum2);            // Same enum value
                $this->assertFalse($enum1 === $enum2);          // Same enum value, but different objects.

                $enum1 = QueueFilterResult::PENDING();
                $enum2 = QueueFilterResult::CRASHED();

                $this->assertNotNull($enum1);
                $this->assertNotSame($enum1, $enum2);                           // Different objects
                $this->assertNotSame($enum1(), $enum2());                       // Different enum value
                $this->assertSame(get_class($enum1), get_class($enum2));        // Same class name
                $this->assertSame(get_class($enum1), QueueFilterResult::class); // Same class name

                $this->assertTrue($enum1 != $enum2);            // Different enum value
                $this->assertTrue($enum1 !== $enum2);           // Different enum objects
        }

}
