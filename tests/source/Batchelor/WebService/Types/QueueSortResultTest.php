<?php

namespace Batchelor\WebService\Types;

use InvalidArgumentException;

/**
 * Generated by PHPUnit_SkeletonGenerator on 2018-08-08 at 19:26:25.
 */
class QueueSortResultTest extends \PHPUnit_Framework_TestCase
{

        /**
         * @var QueueSortResult
         */
        protected $object;

        protected function setUp()
        {
                $this->object = new QueueSortResult();
        }

        public function testDefault()
        {
                $object = $this->object;
                $expect = QueueSortResult::NONE;
                $actual = $object();
                $this->assertSame($actual, $expect);
        }

        public function testGetValue()
        {
                $expect = QueueSortResult::NONE;
                $actual = $this->object->getValue();
                $this->assertSame($actual, $expect);
        }

        public function testHasValue()
        {
                $expect = QueueSortResult::NONE;
                $actual = $this->object->hasValue(QueueSortResult::NONE);
                $this->assertTrue($actual == $expect);

                $expect = QueueSortResult::NONE;
                $actual = $this->object->hasValue(QueueSortResult::NAME);
                $this->assertFalse($actual == $expect);
        }

        public function testGetName()
        {
                $expect = 'NONE';
                $actual = $this->object->getName();
                $this->assertSame($actual, $expect);
        }

        public function testException()
        {
                $constants = $this->object->getConstants();

                foreach ($constants as $constant) {
                        $object = new QueueSortResult($constant);
                }

                $this->expectException(InvalidArgumentException::class);
                $object = new QueueSortResult('missing');
        }

        public function testInvoke()
        {
                $expect = true;
                $actual = is_callable($this->object);
                $this->assertTrue($actual);

                $object = $this->object;        // can't use $this->object with invoke
                $expect = QueueSortResult::NONE;
                $actual = $object();
                $this->assertSame($expect, $actual);
        }

        public function testGetConstants()
        {
                $actual = $this->object->getConstants();
                $this->assertNotNull($actual);
                $this->assertTrue(is_array($actual));
                $this->assertTrue(count($actual) != 0);
        }

        public function testHasConstant()
        {
                $expect = true;
                $actual = $this->object->hasConstant(QueueSortResult::PUBLISHED);
                $this->assertNotNull($actual);
                $this->assertSame($expect, $actual);

                $expect = false;
                $actual = $this->object->hasConstant("missing");
                $this->assertNotNull($actual);
                $this->assertSame($expect, $actual);
        }

        public function testCallStatic()
        {
                $enum1 = QueueSortResult::STATE();   // Create enum object using magic static call
                $enum2 = new QueueSortResult(QueueSortResult::STATE);

                $this->assertNotNull($enum1);
                $this->assertNotSame($enum1, $enum2);                           // Different objects
                $this->assertSame($enum1(), $enum2());                          // Same enum value
                $this->assertSame(get_class($enum1), get_class($enum2));        // Same class name
                $this->assertSame(get_class($enum1), QueueSortResult::class);   // Same class name

                $this->assertTrue($enum1 == $enum2);            // Same enum value
                $this->assertFalse($enum1 === $enum2);          // Same enum value, but different objects.

                $enum1 = QueueSortResult::PUBLISHED();
                $enum2 = QueueSortResult::PUBLISHED();

                $this->assertNotNull($enum1);
                $this->assertNotSame($enum1, $enum2);                           // Different objects
                $this->assertSame($enum1(), $enum2());                          // Same enum value
                $this->assertSame(get_class($enum1), get_class($enum2));        // Same class name
                $this->assertSame(get_class($enum1), QueueSortResult::class);   // Same class name

                $this->assertTrue($enum1 == $enum2);            // Same enum value
                $this->assertFalse($enum1 === $enum2);          // Same enum value, but different objects.

                $enum1 = QueueSortResult::PUBLISHED();
                $enum2 = QueueSortResult::JOBID();

                $this->assertNotNull($enum1);
                $this->assertNotSame($enum1, $enum2);                           // Different objects
                $this->assertNotSame($enum1(), $enum2());                       // Different enum value
                $this->assertSame(get_class($enum1), get_class($enum2));        // Same class name
                $this->assertSame(get_class($enum1), QueueSortResult::class);   // Same class name

                $this->assertTrue($enum1 != $enum2);            // Different enum value
                $this->assertTrue($enum1 !== $enum2);           // Different enum objects
        }

}
